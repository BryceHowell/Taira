// learn to regex in Java

// my cheap ass XML parser should accept a stream as input
// should it buffer????
// it needs to read and recognize tags then act on them
// unmatched and bad tags/data should be recognized and perhaps signaled in STDERR(?)
// good tags and data can either
   // a) be reloaded into a tree data structure to be parsed yet AGAIN
   // b) be loaded directly into world classes (this is not reusable since it becomes a parser only for this proj. )
   // c) be handled via a class instance which provides the function members which handle data appropriately
   // d) not be handled directly in this class (function members are do-nothings) but allow things to be done in a subclass
   
// remember, minimize the amount of work. you might actually want a real XML parser for this
// however it might be nice to have a pseudo-XML parser that handles badly formed XML since I doubt 
// good parsers are set up to half-accept badly formed XML tagged data without bailing out on the parse
// and i'm sure many vendors still fuck up their data

// fuck this. I say, build an event-driven XML parser.
// events:
// text string, with current tag stack included. should I handle entity codes as an additional step?
// (optional) entity code handler or autoconvert table?
// open tag event: adds to stack, allows handling by client. key value hash of tag values avail
// node tag event: stack available, not modified. k-v hash of tag values avail
// close tag event: closed tag, plus stack. obvious pop of tag from stack

import java.awt.image.BufferedImage;
import java.util.Stack;
import java.util.Vector;
import java.util.regex.*;
import java.io.*;

class Tag {
	String tagName;
	Vector attribute;
	Vector value;
	int numberPairs;
	private boolean opening;
	private boolean closing;
	
	Vector subTree;
	Vector<Boolean> subType;
	// subTree is going to contain Strings and tags alternatingly
	// whitespace-only strings will be dumped
	
	Tag() { // the empty tag for the document root
		attribute=new Vector(16,16);
		value=new Vector(16,16);
		numberPairs=0;
		tagName=new String("");
		subTree=new Vector(16,16);
		subType=new Vector<Boolean>(16,16);
	}
	
	Tag(String tagText) {
		// just regex it here
		// match the name
		// then match the individual pairs in order
		// make sure to recognize the type
		subTree=new Vector(16,16);
		subType=new Vector<Boolean>(16,16);
		attribute=new Vector(16,16);
		value=new Vector(16,16);
		numberPairs=0;
		boolean front;
		boolean rear;
		Pattern namePattern=Pattern.compile("<\\s*\\/?\\s*(\\w+)[\\s>]");
		Pattern frontslashPattern=Pattern.compile("<\\s*\\/\\s*\\w");
		Pattern rearslashPattern=Pattern.compile("\\/\\s*>");
		Pattern attributePattern=Pattern.compile("\\s(\\w+)=\"([^\"]*)\"");
		Matcher nomen = namePattern.matcher(tagText);
		if (nomen.find()) { 
			tagName=nomen.group(1);
			}
		Matcher ante = frontslashPattern.matcher(tagText);
		if (ante.find()) front=true; else front=false;
		Matcher post = rearslashPattern.matcher(tagText);
		if (post.find()) rear=true; else rear=false;
		opening=!front;
		closing=front || rear;
		if (!closing) subTree=new Vector(16,16);
		Matcher par = attributePattern.matcher(tagText);
		while (par.find()) {
			attribute.add(par.group(1));
			value.add(par.group(2));
			numberPairs++;
			}
		}
		
	boolean start() { return opening; }
	boolean end() { return closing; }
	String name() { return tagName; }
	
	boolean hasAttribute(String key) {
		for (int i=0; i<numberPairs; i++) {
			String checkKey = (String)attribute.get(i);
			if (checkKey.equalsIgnoreCase(key)) return true;
			}
		return false;
		}
		
	String getValue(String key) {
		for (int i=0; i<numberPairs; i++) {
			String checkKey = (String)attribute.get(i);
			if (checkKey.equalsIgnoreCase(key)) return (String)value.get(i);
			}
		return new String("");
		}
		
	int numberOfPairs() {
		return numberPairs;
		}
		
	String getAttribute(int i) {
		if (0<=i && i<numberPairs) return (String)attribute.get(i); else return new String("");
		}
		
	String getValue(int i) {
		if (0<=i && i<numberPairs) return (String)value.get(i); else return new String("");		
		}
	
	int numberOfElements() {
		return subTree.size();
		}
	
	Object getElement(int i) {
		if (subTree!=null && 0<=i && i<numberOfElements()) // or I could just let it throw an exception...
			return subTree.get(i);
			else return null;
		}
		
	void addElement(Tag t) {
		if (subTree!=null) subTree.add(t);
		if (subType!=null) subType.add(new Boolean(true));
		}

	void addElement(String s) {
		if (subTree!=null) subTree.add(s);
		if (subType!=null) subType.add(new Boolean(false));
		}
		
	void tagPrint() {
		if (!tagName.equalsIgnoreCase("")) {
			System.out.print("<"+tagName+" ");
			for (int i=0; i<attribute.size(); i++) {
				System.out.print((String)attribute.get(i)+"=\""+(String)value.get(i)+"\" ");
				}
			if (end()) System.out.println(" />"); else System.out.println(" >");
				
			}
		for (int i=0; i<subTree.size(); i++) {
			System.out.println("++++ "+subTree.size()+"|"+subType.size()+" ++++");
			Boolean w=subType.get(i);
			boolean which=w.booleanValue();
			if (which) {
				Tag item=(Tag)subTree.get(i);
				item.tagPrint();
				} else {
				System.out.print((String)subTree.get(i));
				}
			}
		}
		
	}
	
	
class ExitTuple {
	boolean brushexit;
	Brush brush;
	String brushname;
	String direction;
	String from;
	Scene fromroom;
	String to;
	int x,y;
	int brushType;
	boolean unlocked;
	}	


class RoomParser {

	// TagParser should receive a stream
	// from there it begins parse, accepting text until a tag occurs... 
	// once tag occurs, crap out the text, then handle the tag event. first handler parses the tag,
	// then kicks it to one of three routines according to type.
	// it might handle broken tag conditions, not sure. I don't need this functionality right now, but perhaps
	// in the future (unmatched tag, broken tag syntax)
	// 
	
	static Vector<Scene> fileRead(String filename, SpriteLibrary SL) {   // image library should be passed in here
		Vector<Scene> data=new Vector<Scene>(16,16);
		Vector<ExitTuple> exitdata=new Vector<ExitTuple>(128,16);
		try
			{
            FileInputStream fstream = new FileInputStream(filename);
			BufferedReader in = new BufferedReader(new InputStreamReader(fstream));
			StringBuffer current=new StringBuffer(8192);
			Pattern tagPattern=Pattern.compile("<\\s*\\/?\\s*\\w+(\\s+\\w+=\"[^\"]*\")*\\s*\\/?\\s*>");
			
			Scene currentroom=new Scene();
			while (in.ready()) {
				String fetch=in.readLine();
				current.append(fetch);
				//System.out.println(fetch);
				String target=current.toString();
				Matcher m = tagPattern.matcher(target);
				int lastend=0;
				boolean tagFound=false;

				while (m.find()) {
					//System.out.println("start" + m.start() + " " +m.end() );
					// I should catch and emit pre-tag text here
					// emit lastend to m.start()-1 for text
					
					//System.out.println("\""+target.substring(lastend,m.start())+"\"");
					String caughtTag=target.substring(m.start(),m.end());
					//System.out.println("|"+caughtTag);
					lastend=m.end();
					
					// should emit/parse tag here
					Tag t=new Tag(caughtTag);
					int pairs=t.numberOfPairs();
					//for (int i=0; i<pairs; i++) {
					//	System.out.print(t.getAttribute(i)+"="+t.getValue(i)+"|");
					//	}
					//System.out.println("TAGNAME ="+t.name());
					if (t.name().equalsIgnoreCase("room") && t.start()) {
						//System.out.println("START ROOM");
						currentroom=new Scene();
						currentroom.setName(t.getValue("name"));
						currentroom.setGroup(t.getValue("group"));
						currentroom.setBackground(t.getValue("bgcolor"));
						if (t.hasAttribute("darkness")) currentroom.darkness=Boolean.valueOf(t.getValue("darkness"));
						}

					if (t.name().equalsIgnoreCase("room") && t.end()) {
						//System.out.println("END ROOM");
						data.add(currentroom);
						currentroom=null;
						}
					if (t.name().equalsIgnoreCase("exit") && t.start()) { // modify to handle the case of an exit that targets a brush
						//System.out.println("GOT EXIT");
						ExitTuple e=new ExitTuple();
						if (t.hasAttribute("direction")) {
							e.brushexit=false;
							e.direction=t.getValue("direction");
							e.from=currentroom.getName();
							e.fromroom=currentroom;
							e.to=t.getValue("room");
							} 
						if (t.hasAttribute("brush")) {
							e.brushexit=true;
							e.brushname=t.getValue("brush");
							e.from=currentroom.getName();
							e.fromroom=currentroom;
							e.to=t.getValue("room");
							e.x=Integer.valueOf(t.getValue("x"));
							e.y=Integer.valueOf(t.getValue("y"));
							e.unlocked=Boolean.valueOf(t.getValue("unlocked"));
							String btype=t.getValue("type");
							if (btype.equalsIgnoreCase("BLOCK")) e.brushType=Brush.BLOCK;
							if (btype.equalsIgnoreCase("GATE")) e.brushType=Brush.GATE;
							if (btype.equalsIgnoreCase("PIT")) e.brushType=Brush.PIT;
							if (btype.equalsIgnoreCase("STAIRS")) e.brushType=Brush.STAIRS;							
							} 
							
						exitdata.add(e);
						}
					if (t.name().equalsIgnoreCase("brush") && t.start()) { // needs to check for named brushes. will need a register for that 
						//System.out.println("GOT BRUSH");
						String bcol=t.getValue("color");
						int x=Integer.valueOf(t.getValue("x"));
						int y=Integer.valueOf(t.getValue("y"));
						int z=Integer.valueOf(t.getValue("z"));
						int width=Integer.valueOf(t.getValue("width"));
						int height=Integer.valueOf(t.getValue("height"));
						Brush b=new Brush(bcol,x,y,z,width,height);
						if (t.hasAttribute("name")) b.name=t.getValue("name");
						if (t.hasAttribute("image")) { b.imagename=t.getValue("image"); b.gfx=Brush.DECAL; b.decal=SL.nameSearch(b.imagename).pix[0]; }
						if (t.hasAttribute("drawn")) { b.drawn=Boolean.valueOf(t.getValue("drawn")); }
						currentroom.addBrush(b);
						}

					// Just convert tags to data here

					//System.out.print("\n");
					tagFound=true;
					}
				if (tagFound) current.delete(0,lastend);  
				}
				// emit remaining text before closing file
				in.close();
			} catch (Exception e) {
			System.err.println(e.toString());
			}
	
	
	try {
	// NEXT STEP: BIND CARDINAL EXITS
	//System.out.println("TOTAL ROOMS:"+exitdata.size());
	for (int i=0; i<exitdata.size(); i++) {
		ExitTuple e=exitdata.get(i);
		// for each exit, search for target room
		String targetname=e.to;
		Scene targetroom=null;
		//System.out.println(" ||| "+targetname);
		for (int j=0; j<data.size(); j++) {
			if (targetname.equalsIgnoreCase(data.get(j).getName())) { targetroom=data.get(j); break; }
			}
		//if (targetroom==null) System.out.println("FAILED TO RESOLVE TARGETROOM"); else System.out.println(targetname+" is the room");
		if (!e.brushexit) {
			int index=4;
			if (e.direction.equalsIgnoreCase("north")) index=1;
			if (e.direction.equalsIgnoreCase("south")) index=7;
			if (e.direction.equalsIgnoreCase("east")) index=5;
			if (e.direction.equalsIgnoreCase("west")) index=3;
			e.fromroom.exitList[index]=targetroom;
			} else {
			// search fromroom for the brush
			//System.out.println(e.fromroom.getName()+" to "+targetroom.getName());
			//System.out.println(e.brushname);
			if (e.fromroom.brushList==null) System.out.println("NULL FROMROOM brushlist"); 
			for (int j=0; j<e.fromroom.brushList.size(); j++) {
				//System.out.println("j is "+j+"  "+e.fromroom.brushList.get(j).name);
				if (e.fromroom.brushList.get(j).name.equalsIgnoreCase(e.brushname)) { e.brush=e.fromroom.brushList.get(j); break; }
				}  // DOES NOT SIGNAL FAILURE TO FIND.. will give out of bounds index
			
			// set exitScene, exitX, exitY
			e.brush.exitScene=targetroom;
			e.brush.exitX=e.x;
			e.brush.exitY=e.y;
			e.brush.unlocked=e.unlocked; e.brush.type=e.brushType;
			// set type
			
			}
		}	
	} catch (Exception e) {
	System.err.println(e.toString());
	}	


	return data;
	}
	
	
	public static void main(String [] args) {
		Vector<Scene> rooms=null;
		if (args.length>=1) rooms=fileRead(args[0],null); else
			System.err.println("Invalid parameters");
		System.out.println("NUMBER OF ROOMS: "+rooms.size());
		
	}

	

}
